#! /usr/bin/env python3

# HTTP(S) Request / Response investigation


import sys, pathlib, argparse
import http.client
from http.cookies import SimpleCookie
import socket, ssl, urllib.parse, getpass
from cryptography import x509
from cryptography.x509.oid import ExtensionOID
from base64 import b64encode
from html.parser import HTMLParser
from copy import deepcopy


# some settings
schemes = ['http','https']
redirect_codes = [301, 302, 303, 307, 308]
useragents = {
    'Mac-Safari': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Safari/605.1.15',
    'iPhone-Safari': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.2 Mobile/15E148 Safari/604.1',
    'foobar': 'FooBar/1.0',
}
cert_subj_str = ''
auth_id = ''
auth_passphrase = ''
#auth_passphrase = getpass.getpass(f'passphrase:')
socket.setdefaulttimeout(5)
socket.has_ipv6 = False
last_cat = ''
cookiedb = SimpleCookie()


# ANSI SGR formatting sequences
def f(code) -> str: return '\x1b[' + str(code) + 'm'
def c(code) -> str: return f('38;5;' + str(code))

# warnings
def warn(msg:str):
    print(c(196) + str(msg) + f(39), file=sys.stderr)

# print key:value pairs
def print_item(item:tuple):
    global last_cat
    if len(item) != 3:
        warn('print_item syntax error: ' + str(item))
        sys.exit(1)
    cat, key, value = item
    if cat != last_cat:
        print('\n' + f(3)+f(4) + str(cat) + ':' + f(24)+f(23))
        last_cat = cat
    if  ((cat == 'Response headers') and (key.lower() =='location')) or \
        ((cat == 'Response headers') and (key.lower() =='server')) or \
        ((cat == 'Response headers') and (key.lower() =='www-authenticate')) or \
        ((cat == 'Server certificate') and (key.lower() =='subject')) or \
        ((cat == 'Socket details') and (key.lower() =='real-peername')) or \
        ((cat == 'Response headers') and (key.lower() =='set-cookie')) or \
        ((cat == 'Request headers') and (key.lower() =='cookie')):
        print(c(228) + str(key) + ':' + f(39), str(value))
    else:
        print(c(230) + str(key) + ':' + f(39), str(value))

# parse arguments
def get_arguments(my_name:str) -> argparse.Namespace:
    parser = argparse.ArgumentParser(prog=my_name)
    parser.add_argument('URL',
                        type=str,
                        help='e. g. http://www.foobar.net:80/index.html')
    parser.add_argument('--cookies',
                        action='store_true',
                        required=False,
                        help='send cookies')
    parser.add_argument('--secure',
                        action='store_true',
                        required=False,
                        help='do https')
    return parser.parse_args()

# ask for a target / location
def ask_location() -> dict:
    location = {'scheme':'', 'host':'', 'port':0, 'path':''}
    while not (location['scheme'] in schemes):
        location['scheme'] = input('Scheme: ').strip().lower()
    while not location['host']:
        location['host'] = input('Host: ').strip().lower()
    while not location['port']:
        try:
            location['port'] = int(input('Port: ').strip())
        except ValueError:
            pass
    location['path'] = input('Path: ').strip()
    if not location['path']:
        location['path'] = '/'
    # return the dictionary
    return location

# do an HTTP request to location
def http_request(location:dict) -> http.client.HTTPResponse:
    global cookiedb
    try:
        print_item(('Connection details', 'Target', location))
        # do DNS resolution
        ip = socket.gethostbyname(location['host'])
        print_item(('Connection details', 'DNS-resolution', ip))
        # connection object
        connection = http.client.HTTPConnection(location['host'],
                                                location['port'])
        #print_item(('Connection details', 'Connection-Obj', connection))
        # request headers
        request_headers = {}
        request_headers['User-Agent'] = useragents['Mac-Safari']
        if cookiedb:
            cookie_header = '; '.join(f'{m.key}={m.value}' for m in cookiedb.values())
            request_headers['Cookie'] = cookie_header
        # never send Authorization header without encryption!
        for request_header in request_headers:
            print_item(('Request headers', request_header, request_headers[request_header]))
        # the request
        #connection.set_debuglevel(1)
        connection.request('GET', location['path'], headers=request_headers)
        print_item(('Socket details', 'Real-Peername', connection.sock.getpeername()[0]))
        return connection.getresponse()
    except KeyboardInterrupt:
        warn('KeyboardInterrupt')
        sys.exit(1)
    except Exception as e:
        warn('Connection error: ' + str(e))
        sys.exit(1)

# do an HTTPS request to location
def https_request(location:dict) -> http.client.HTTPResponse:
    global cookiedb
    try:
        print_item(('Connection details', 'Location', location))
        # do DNS resolution
        ip = socket.gethostbyname(location['host'])
        print_item(('Connection details', 'DNS-resolution', ip))
        # ssl context
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        print_item(('Connection details', 'SSL-context', ctx))
        # connection object
        connection = http.client.HTTPSConnection(location['host'],
                                                location['port'],
                                                context=ctx)
        #print_item(('Connection details', 'Connection-Obj', connection))
        # ssl-connection
        #connection.set_debuglevel(1)
        connection.connect()
        print_item(('Socket details', 'Real-Peername', connection.sock.getpeername()[0]))
        # certificate
        der_cert = connection.sock.getpeercert(binary_form=True)
        cert = ''
        if der_cert:
            cert = x509.load_der_x509_certificate(der_cert)
            print_item(('Server certificate', 'Subject', cert.subject.rfc4514_string()))
            print_item(('Server certificate', 'Issuer', cert.issuer.rfc4514_string()))
            print_item(('Server certificate', 'Not-after', str(cert.not_valid_after_utc)))
            # Subject (O)
            subject = cert.subject.rfc4514_string()
            while '\\,' in subject: subject = subject.replace('\\,', '﹐')
            subject_items = subject.split(',')
            place, state, country = ('','','')
            for item in subject_items:
                key, _, value = item.partition('=')
                if key.upper() == 'O':
                    print_item(('Parsed cert items', 'Org', c(154) + value + f(39)))
                elif key.upper() == 'C':
                    country = deepcopy(value)
                elif key.upper() == 'ST':
                    state = deepcopy(value)
                elif key.upper() == 'L':
                    place = deepcopy(value)
            if place or state or country:
                loc = []
                if country: loc.append(country)
                if state: loc.append(state)
                if place: loc.append(place)
                print_item(('Parsed cert items', 'Place', ' › '.join(loc)))
            # Subject Alternative Name (SAN)
            try:
                san = cert.extensions.get_extension_for_oid(ExtensionOID.SUBJECT_ALTERNATIVE_NAME).value
                san_names = san.get_values_for_type(x509.DNSName) # type: ignore
                san_list = []
                for name in san_names:
                    name = c(157) + name + f(39)
                    san_list.append(name)
                print_item(('Parsed cert items', 'SANs', ', '.join(san_list)))
            except:
                warn('cert error: no SAN found?!')
            # Issuer
            issuer = cert.issuer.rfc4514_string()
            while '\\,' in issuer: issuer = issuer.replace('\\,', '﹐')
            issuer_items = issuer.split(',')
            for item in issuer_items:
                key, _, value = item.partition('=')
                if key.upper() == 'O':
                    print_item(('Parsed cert items', 'Issuer', value))
        else:
            warn('cert error: no certificate?!')
        # request headers
        request_headers = {}
        request_headers['User-Agent'] = useragents['Mac-Safari']
        if cookiedb:
            cookie_header = '; '.join(f'{m.key}={m.value}' for m in cookiedb.values())
            request_headers['Cookie'] = cookie_header
        if cert and cert_subj_str and auth_id and auth_passphrase:
            if cert_subj_str == cert.subject.rfc4514_string():
                credentials = f'{auth_id}:{auth_passphrase}'
                b64 = b64encode(credentials.encode('ascii'))
                request_headers['Authorization'] = f'Basic {b64.decode('ascii')}'
        for request_header in request_headers:
            print_item(('Request headers', request_header, request_headers[request_header]))
        # the request
        connection.request('GET', location['path'], headers=request_headers)
        return connection.getresponse()
    except KeyboardInterrupt:
        warn('KeyboardInterrupt')
        sys.exit(1)
    except Exception as e:
        warn('Connection error: ' + str(e))
        sys.exit(1)

# title, descr and meta parser
class TitleParser(HTMLParser):
    def __init__(self):
        super().__init__()
        self.in_title = False
        self.title = ''
        self.meta = []
        self.descr = ''
        self.author = ''
        self.keywords = ''
        self.generator = ''
    def handle_starttag(self, tag, attrs):
        if (tag.lower() == 'title') and (not self.title):
            self.in_title = True
        elif (tag.lower() == 'meta') and attrs:
            self.meta.append(attrs)
            attrdb = {}
            for attr in attrs:
                key, value = attr
                attrdb[key] = value
            if ('name' in attrdb) and ('content' in attrdb):
                match attrdb['name'].lower():
                    case 'description': self.descr =     deepcopy(attrdb['content'])
                    case 'author':      self.author =    deepcopy(attrdb['content'])
                    case 'keywords':    self.keywords =  deepcopy(attrdb['content'])
                    case 'generator':   self.generator = deepcopy(attrdb['content'])
    def handle_endtag(self, tag):
        if tag.lower() == 'title':
            self.in_title = False
    def handle_data(self, data):
        if self.in_title:
            self.title += data.strip()

# main program
def main() -> int:
    # my path
    my_path = pathlib.Path(__file__)
    my_dir  = str(my_path.parent)
    my_name = str(my_path.name)
    # get arguments
    arguments = get_arguments(my_name)
    url = str(arguments.URL)
    if not (url.lower().startswith('http://') or url.lower().startswith('https://')):
        url = 'https://' + url if arguments.secure else 'http://' + url
    # parse url -> location dict
    location_parsed = urllib.parse.urlparse(url)
    location = {'scheme':'', 'host':'', 'port':0, 'path':''}
    #scheme
    if location_parsed.scheme:
        location['scheme'] = location_parsed.scheme.lower()
    elif arguments.secure:
        location['scheme'] = 'https'
    else:
        location['scheme'] = 'http'
    # host and port
    location['host'], _, port_string = location_parsed.netloc.partition(':')
    if port_string: location['port'] = int(port_string)
    elif location['scheme'] == 'http': location['port'] = 80
    elif location['scheme'] == 'https': location['port'] = 443
    # path
    path = location_parsed.path if location_parsed.path else '/'
    if location_parsed.query:
        path += '?' + location_parsed.query
    if location_parsed.fragment:
        path += '#' + location_parsed.fragment
    location['path'] = path
    last_location = ''

    # ask for location
    #location = ask_location()

    # main loop
    while True:
        if location == last_location:
            warn('STOP: new request with same location details as last request:')
            print(location)
            return 1
        last_location = deepcopy(location)
        new_url = f'{location['scheme']}://{location['host']}:{location['port']}{location['path']}'
        print(f'\n\n\n{f(1)}> REQUEST {f(7)}{f(4)}{new_url}{f(24)}{f(27)}{f(22)}')
        # do request, get response
        if location['scheme'] == 'http':
            response = http_request(location)
        elif location['scheme'] == 'https':
            response = https_request(location)
        else:
            warn('bad scheme: only http or https allowed')
            return 1
        # response version and statuscode
        match response.version:
            case 10: version = 'HTTP/1.0'
            case 11: version = 'HTTP/1.1'
            case _:  version = 'HTTP/' + str(response.version)
        if response.status == 200: color = f(32) # green
        elif response.status in redirect_codes: color = f(33) # yellow
        else: color = f(31) # red
        print(f'\n\n{color}> RESPONSE {f(7)}{version} {response.status} {response.reason}{f(27)}{f(39)}')
        # response headers
        headers = response.getheaders()
        for header in headers:
            key, value = header
            if key.lower() == 'set-cookie':
                if arguments.cookies:
                    cookiedb.load(value)
                cookie, _, attributes = value.partition('; ')
                cookie_name, _, cookie_value = cookie.partition('=')
                new_value = cookie_name + '='
                new_value += cookie_value + '; '
                new_value += attributes
                print_item(('Response headers', key, new_value))
            else:
                print_item(('Response headers', key, value))
        if cookiedb:
            for cookie_key, cookie_morsel in cookiedb.items():
                print_item(('Stored cookies', cookie_key, f'{c(222)}{cookie_morsel.value}{f(39)}'))
        # payload
        payload = response.read()
        if len(payload.strip()) > 1:
            print('\n' + f(3)+f(4) + 'Payload (decoded):' + f(24)+f(23))
            try: text = payload.decode('utf-8')
            except UnicodeDecodeError: 
                try: text = payload.decode('latin-1')
                except UnicodeDecodeError:
                    warn('error decoding payload: unknown charset')
                    return 1
            text = text.strip().strip('\n')
            while 2*'\n' in text: text = text.replace(2*'\n', '\n')
            if len(text) < 1024:
                print( f(2) + str(text)  + f(22) )
            else:
                print( f(2) + str(text[:1024]) + c(196)+'…'+f(39) + 2*'\n'
                    + c(196)+'…'+f(39) + str(text[-128:]) + f(22))
            # parse HTML payload
            p = TitleParser()
            p.feed(text)
            # print title and meta tags
            title = p.title
            while ('\t' in title):
                title = title.replace('\t', 2 * '\x20')
            while (3 * '\x20' in title):
                title = title.replace(3 * '\x20', 2 * '\x20')
            print_item(('Parsed items', 'Title', c(222) + title + f(39)))
            if p.descr:
                print_item(('Parsed items', 'Descr', f(3)+c(222) + p.descr + f(39)+f(23)))
            if p.author:
                print_item(('Parsed items', 'Author', c(222) + p.author + f(39)))
            if p.keywords:
                keywords_list = p.keywords.split(',')
                keywords = []
                for keyword in keywords_list:
                    keywords.append(c(222) + keyword.strip() + f(39))
                print_item(('Parsed items', 'Keywords', ', '.join(keywords)))
            if p.generator:
                print_item(('Parsed items', 'Generator', c(222) + p.generator + f(39)))
            for meta_tag in p.meta:
                meta_line = ''
                for meta_attr in meta_tag:
                    meta_key, meta_value = meta_attr
                    meta_line += f'{c(230)}{meta_key}{f(39)}={meta_value} '
                print_item(('Meta tags', 'Meta', meta_line))



        # 200 OK
        if response.status == 200:
            print('OK, done. All cookies crunched.')
            return 0

        # 3xx redirect
        elif (response.status in redirect_codes) and response.getheader('location'):
            response_location_parsed = urllib.parse.urlparse(str(response.getheader('location')))

            # set the scheme
            response_scheme = str(response_location_parsed.scheme).lower()
            if response_scheme:
                if response_scheme != location['scheme']:
                    # server wants a different scheme
                    if response_scheme in schemes:
                        location['scheme'] = response_scheme
                        # change the port also
                        match response_scheme:
                            case 'http':  location['port'] = 80
                            case 'https': location['port'] = 443
                    else:
                        warn(f'scheme "{response_scheme}" not supported')
                        return 1

            # set the port
            if response_location_parsed.port:
                location['port'] = response_location_parsed.port
            # port in netloc (www.foobar.net:8080)
            if ':' in str(response_location_parsed.netloc):
                _, __, location['port'] = str(response_location_parsed.netloc).partition(':')

            # set the hostname
            if response_location_parsed.hostname:
                location['host'] = str(response_location_parsed.hostname).lower()

            # set the path
            if response_location_parsed.path:
                path = str(response_location_parsed.path)
            else:
                path = '/'
            if not path.startswith('/'):
                path = '/' + path
            if response_location_parsed.query:
                path += '?' + str(response_location_parsed.query)
            if response_location_parsed.fragment:
                path += '#' + str(response_location_parsed.fragment)
            location['path'] = path

        # error statuscode?
        else:
            return 1

    return 1

if __name__ == '__main__':
    sys.exit(main())
